{"attrs":{"x":-4,"y":0,"outputs":{"image":{"uid":"17648244dd2-f9fe-1b1c-8e0c-946e","key":"image"}}},"nodes":[{"key":"voxel-render-code","x":-63.5,"y":-192.75,"uid":"17642a8b8ca-b941-b999-6640-2c39","inputs":{"mat":{"uid":"17642af117b-2a5f-4d7b-d569-34a6","key":"mat"}},"forms":{"code":"#include voxel-base;\n\n//投射最大步进次数\nconst int MAX_STEP_NUM = 100;\n//最小命中距离\nconst float MIN_HIT_LENGTH = 0.001;\n//投射远距离\nconst float MAX_RAY_LENGTH = 1000.0;\n//梯度计算差值\nconst float PIX_SPACING = 0.001;\n\n//命中信息结构体\nstruct HitInfo {\n    vec3 pos;//起点\n    vec3 step;//步进向量\n};\n\n//获取一个圆的有向距离\nfloat sphereSDF(vec3 p,vec3 c, float r) {\n    return length(p - c) - r;\n}\n\n//获取场景的有向距离\nfloat MapSDF(vec3 pos){\n    return sphereSDF(pos,vec3(0,0,uArgs1),uArgs2);\n}\n\n//获取点的法向\nvec3 PointNormal(vec3 p) {\n    return normalize(vec3(\n        MapSDF(vec3(p.x + PIX_SPACING, p.y, p.z)) - MapSDF(vec3(p.x - PIX_SPACING, p.y, p.z)),\n        MapSDF(vec3(p.x, p.y + PIX_SPACING, p.z)) - MapSDF(vec3(p.x, p.y - PIX_SPACING, p.z)),\n        MapSDF(vec3(p.x, p.y, p.z  + PIX_SPACING)) - MapSDF(vec3(p.x, p.y, p.z - PIX_SPACING))\n    ));\n}\n\n//命中目标\nfloat RayHitTo(Ray ray){\n    //当前投射长度\n    float len = 0.0;\n    //循环投射\n    for (int i = 0; i < MAX_STEP_NUM; i++) {\n        //获取有向距离\n        float dist = MapSDF(ray.pos + ray.step * len);\n        //命中成功\n        if (dist < MIN_HIT_LENGTH)\n\t\t\treturn len;\n\t\t//步进\n        len += dist;\n        //如果过大则退出\n        if(len > MAX_RAY_LENGTH)\n            return len;\n    }\n    return len;\n}\n\n//主函数\nvoid run(){\n\t//初始化投射光线\n\tRay ray;\n\tray.pos = (uViewMat * vec4(0,0,-1.0,1)).xyz;\n\tray.step = normalize((uViewMat * vec4(vUV - 0.5,0.8,1)).xyz);\n\t\n\t//命中运算\n\tfloat len = RayHitTo(ray);\n\tlen = 1.0 - len;\n\t\n\t//距离着色\n\toutColor = vec4(len,len,len,1);\n}","args1":0,"args2":0.428,"args3":0,"args4":0},"level":-1,"cache":{}},{"key":"voxel-mat-view","x":-343.5,"y":-169.75,"uid":"17642af117b-2a5f-4d7b-d569-34a6","inputs":{},"forms":{},"level":-1,"cache":{}},{"key":"voxel-render-code","x":-61,"y":-104.75,"uid":"176431a0b91-802f-3dc6-02f8-7615","inputs":{"mat":{"uid":"17642af117b-2a5f-4d7b-d569-34a6","key":"mat"}},"forms":{"code":"#include voxel-base;\n\n//投射最大步进次数\nconst int MAX_STEP_NUM = 300;\n//最小命中距离\nconst float MIN_HIT_LENGTH = 0.0001;\n//投射远距离\nconst float MAX_RAY_LENGTH = 2000.0;\n//梯度计算差值\nconst float PIX_SPACING = 0.0001;\n\n//平滑最小值\nfloat smin( float a, float b, float k )\n{\n    k = max(0.00001,k);\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n//平滑最大值\nfloat smax( float a, float b, float k )\n{\n    k = max(0.00001,k);\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n//获取一个平面的有向距离\nfloat planSDF(vec3 p,float z) {\n    return p.z - z;\n}\n\n//获取一个圆的有向距离\nfloat sphereSDF(vec3 p,vec3 c, float r) {\n    return length(p - c) - r;\n}\n\n//获取场景的有向距离\nfloat MapSDF(vec3 pos){\n    //return sphereSDF(pos,vec3(0,0,uArgs2),0.3);\n    return smin(planSDF(pos,-0.2),sphereSDF(pos,vec3(0,0,0.3-uArgs2),0.3),uArgs1);\n    //return min(planSDF(pos,-0.2),sphereSDF(pos,vec3(0,0,0.3-uArgs2),0.3));\n    //return max(planSDF(pos,-0.2),sphereSDF(pos,vec3(0,0,0.3-uArgs2),0.3));\n    //return smax(planSDF(pos,-0.2),sphereSDF(pos,vec3(0,0,0.3-uArgs2),0.3),uArgs1);\n}\n\n//获取点的法向\nvec3 PointNormal(vec3 p) {\n    return normalize(vec3(\n        MapSDF(vec3(p.x + PIX_SPACING, p.y, p.z)) - MapSDF(vec3(p.x - PIX_SPACING, p.y, p.z)),\n        MapSDF(vec3(p.x, p.y + PIX_SPACING, p.z)) - MapSDF(vec3(p.x, p.y - PIX_SPACING, p.z)),\n        MapSDF(vec3(p.x, p.y, p.z  + PIX_SPACING)) - MapSDF(vec3(p.x, p.y, p.z - PIX_SPACING))\n    ));\n}\n\n//命中目标\nbool RayHitTo(Ray ray,inout float len){\n    //当前投射长度\n    len = 0.0;\n    //循环投射\n    for (int i = 0; i < MAX_STEP_NUM; i++) {\n        //获取有向距离\n        float dist = MapSDF(ray.pos + ray.step * len);\n        //命中成功\n        if (dist < MIN_HIT_LENGTH)\n\t\t\treturn true;\n\t\t//步进\n        len += dist;\n        //如果过大则退出\n        if(len > MAX_RAY_LENGTH)\n            return false;\n    }\n    //指定次数内没命中\n    return false;\n}\n\n//主函数\nvoid run(){\n    //默认黑色\n    outColor = vec4(0,0,0,1);\n    \n\t//初始化投射光线\n\tRay ray;\n\tray.pos = (uViewMat * vec4(0,0,-1.0,1)).xyz;\n\tray.step = normalize((uViewMat * vec4(vUV - 0.5,0.8,1)).xyz);\n\t\n\t//命中运算\n\tfloat len = 0.0;\n\tif(RayHitTo(ray,len)){\n\t    //获取法向\n\t    vec3 normal = PointNormal(ray.pos + ray.step * len);\n\t    //法向着色\n\t    outColor = vec4(normal * 0.5 + 0.5,1);\n\t}\n}","args1":0.162,"args2":0.267,"args3":0,"args4":0},"level":-1,"cache":{}},{"key":"voxel-render-code","x":-62,"y":-16.75,"uid":"17648244dd2-f9fe-1b1c-8e0c-946e","inputs":{"mat":{"uid":"1764d539008-5f4e-68f1-47fc-c6a3","key":"mat"}},"forms":{"code":"#include voxel-base;\r\n\r\n//投射最大步进次数\r\nconst int MAX_STEP_NUM = 350;\r\n//最小命中距离\r\nconst float MIN_HIT_LENGTH = 0.0001;\r\n//投射远距离\r\nconst float MAX_RAY_LENGTH = 2000.0;\r\n//梯度计算差值\r\nconst float PIX_SPACING = 0.0001;\r\n\r\n//光线方向\r\nvec3 light_dir = vec3(-1,0.5,0.7);\r\n//视图矩阵逆矩阵\r\nmat4 iViewMat;\r\n\r\n//平滑最小值\r\nfloat smin( float a, float b, float k )\r\n{\r\n    k = max(0.00001,k);\r\n    float h = max(k-abs(a-b),0.0);\r\n    return min(a, b) - h*h*0.25/k;\r\n}\r\n\r\n//平滑最大值\r\nfloat smax( float a, float b, float k )\r\n{\r\n    k = max(0.00001,k);\r\n    float h = max(k-abs(a-b),0.0);\r\n    return max(a, b) + h*h*0.25/k;\r\n}\r\n\r\n//获取一个平面的有向距离\r\nfloat planSDF(vec3 p,float z) {\r\n    return p.z - z;\r\n}\r\n\r\n//获取一个圆的有向距离\r\nfloat sphereSDF(vec3 p,vec3 c, float r) {\r\n    return length(p - c) - r;\r\n}\r\n\r\n//方块的有向距离\r\nfloat boxSDF(vec3 p,vec3 b)\r\n{\r\n    vec3 d = abs(p) - b;\r\n    return min( max(max(d.x,d.y),d.z),0.0) + length(max(d,0.0));\r\n}\r\n\r\n//获取场景的有向距离和材质\r\nfloat MapSDF(vec3 pos,inout int mat){\r\n    //使用视图旋转内容本身\r\n    vec3 ipos = (uViewMat * vec4(pos,1.0)).xyz;\r\n\r\n    //当前显示目标sdf\r\n    float starget = sphereSDF(ipos,vec3(0,0,0),uArgs2 + 0.2);\r\n    float target = boxSDF(ipos,vec3(uArgs1 + 0.1,uArgs1 + 0.1,uArgs1 + 0.1));\r\n    target = smax(-starget,target,0.1);\r\n\r\n    //混合地面\r\n    float plans = smin(planSDF(pos,-0.7),1.0 - pos.x,0.1);\r\n    if(plans < target)\r\n        mat = 0;\r\n    else\r\n        mat = 1;\r\n    return min(plans,target);\r\n}\r\n\r\n//获取有向距离\r\nfloat MapSDF(vec3 pos){\r\n    int mat;\r\n    return MapSDF(pos,mat);\r\n}\r\n\r\n//获取点的法向\r\nvec3 PointNormal(vec3 p) {\r\n    return normalize(vec3(\r\n        MapSDF(vec3(p.x + PIX_SPACING, p.y, p.z)) - MapSDF(vec3(p.x - PIX_SPACING, p.y, p.z)),\r\n        MapSDF(vec3(p.x, p.y + PIX_SPACING, p.z)) - MapSDF(vec3(p.x, p.y - PIX_SPACING, p.z)),\r\n        MapSDF(vec3(p.x, p.y, p.z  + PIX_SPACING)) - MapSDF(vec3(p.x, p.y, p.z - PIX_SPACING))\r\n    ));\r\n}\r\n\r\n//命中目标\r\nbool RayHitTo(Ray ray,inout float len,inout int mat){\r\n    //当前投射长度\r\n    len = 0.0;\r\n    //循环投射\r\n    for (int i = 0; i < MAX_STEP_NUM; i++) {\r\n        //获取有向距离\r\n        float dist = MapSDF(ray.pos + ray.step * len,mat);\r\n        //命中成功\r\n        if (dist < MIN_HIT_LENGTH)\r\n            return true;\r\n        //限制最小步进长度\r\n        dist = max( dist, 0.001);\r\n        //步进\r\n        len += dist;\r\n        //如果过大则退出\r\n        if(len > MAX_RAY_LENGTH)\r\n            return false;\r\n    }\r\n    //指定次数内没命中\r\n    return false;\r\n}\r\n\r\n//主函数\r\nvoid run(){\r\n    //默认黑色\r\n    outColor = vec4(0,0,0,1);\r\n\r\n    //计算视图逆矩阵\r\n    iViewMat = inverse(uViewMat);\r\n\r\n    //归一化光线向量\r\n    light_dir = normalize(light_dir);\r\n    \r\n    //初始化投射光线\r\n    Ray ray;\r\n    ray.pos = (vec4(-1.8,0,0,1)).xyz;\r\n    ray.step = normalize((vec4(0.8,0.5 - vUV,1)).xyz);\r\n    \r\n    //命中运算\r\n    float len = 0.0;\r\n    int mat = 0;\r\n    if(RayHitTo(ray,len,mat)){\r\n        //获取法向\r\n        vec3 normal = PointNormal(ray.pos + ray.step * len);\r\n        float v = (dot(normal,light_dir) + 1.0) / 2.0;\r\n        v = v * 0.6 + 0.4;\r\n        //光照着色\r\n        if(mat == 0)\r\n            outColor = vec4(mix(vec3(0,0,0),vec3(0.54,0.82,1),v),1);\r\n        else{\r\n            vec4 pos = vec4(ray.pos + ray.step * len,1.0);\r\n            pos = uViewMat * pos;\r\n            float c = pos.x * pos.y * pos.z;\r\n            if(c < 0.0)\r\n                outColor = vec4(mix(vec3(0,0,0),vec3(1,1,1),v),1);\r\n            else\r\n                outColor = vec4(mix(vec3(0,0,0),vec3(0.8,0.8,0.8),v),1);\r\n        }\r\n\r\n        //阴影检测\r\n        ray.pos = ray.pos + ray.step * len + normal * 0.0011 * 2.0;\r\n        ray.step = light_dir;\r\n        len = 0.0;\r\n        if(RayHitTo(ray,len,mat)){\r\n            outColor = mix(outColor,vec4(0,0,0,1),0.4);\r\n        }else{\r\n            v = (1.0 - max(min(dot(normal,light_dir) * 7.0,1.0),0.0));\r\n            outColor = mix(outColor,vec4(0,0,0,1),0.4 * v);\r\n        }\r\n    }\r\n}","args1":0.312,"args2":0.269,"args3":0,"args4":0},"level":0,"cache":{}},{"key":"voxel-mat-obj-rotate","x":-346,"y":-19.75,"uid":"1764d539008-5f4e-68f1-47fc-c6a3","inputs":{},"forms":{},"level":1,"cache":{}}]}